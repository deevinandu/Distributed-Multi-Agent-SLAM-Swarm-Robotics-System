================================================================================
DISTRIBUTED SLAM AND SWARM ROBOTICS PROJECT GUIDE
================================================================================

1. OVERVIEW
-----------
This project implements a Distributed Multi-Agent SLAM (Simultaneous Localization 
and Mapping) system. It allows multiple resource-constrained robots (ESP32) to 
collaboratively map an environment by offloading the heavy computational tasks 
to a central ROS 2 server.

2. HOW IT WORKS
---------------
The system is divided into two main layers:

A. AGENT LAYER (ESP32 Robots):
   - State Estimation: Each robot runs an Extended Kalman Filter (EKF) to fuse 
     high-frequency IMU data (100Hz) with wheel odometry (10-20Hz).
   - Data Streaming: The robots act as data publishers, streaming their refined 
     odometry (location/orientation) and raw LiDAR scans to the central server 
     via Micro-ROS over Wi-Fi.
   - Current State: The firmware currently includes "stub" functions that 
     generate synthetic data for testing. To use real hardware, you must 
     replace these stubs with actual sensor drivers in `main.cpp`.

B. SERVER LAYER (Central PC):
   - Local Mapping: The server runs an individual instance of 'slam_toolbox' 
     for each agent. This creates local maps based on each robot's sensor data.
   - Map Merging: A custom Python node (`map_merger.py`) subscribes to all local 
     maps. It uses the Iterative Closest Point (ICP) algorithm from the 
     Open3D library to align and stitch these local maps into one global map.
   - Validation: The system checks the 'fitness' of the map alignment to ensure 
     the global map remains accurate and isn't corrupted by bad sensor data.

3. HARDWARE SETUP & WIRING
-------------------------
To build the robots, connect the components to the ESP32 as follows:

| Component       | ESP32 Pin | Function       | Notes                      |
| :-------------- | :-------- | :------------- | :------------------------- |
| **MPU6050**     | GPIO 21   | SDA            | I2C Data                   |
| (IMU)           | GPIO 22   | SCL            | I2C Clock                  |
| **VL53L0X**     | GPIO 21   | SDA            | Shared I2C Bus             |
| (LiDAR)         | GPIO 22   | SCL            | Shared I2C Bus             |
| **L298N (Left)**| GPIO 32   | ENA (PWM)      | Speed Control              |
|                 | GPIO 33   | IN1            | Direction                  |
|                 | GPIO 25   | IN2            | Direction                  |
| **L298N (Right)**| GPIO 26   | ENB (PWM)      | Speed Control              |
|                 | GPIO 27   | IN3            | Direction                  |
|                 | GPIO 14   | IN4            | Direction                  |
| **Encoders**    | GPIO 34   | Left Signal    | Input Only Pin             |
| (Speed Feedbk)  | GPIO 35   | Right Signal   | Input Only Pin             |
| **HC-SR04+**    | GPIO 5    | Trig           | Trigger Pulse              |
| (Ultrasonic)    | GPIO 18   | Echo           | Echo Return                |

POWER CONNECTIONS:
- Batteries: 2x 18650 (7.4V) -> L298N 12V Input.
- Logic Power: L298N 5V Out (if available) OR LM2596 Buck Converter (set to 5V) 
  -> ESP32 Vin/5V pin.
- Common Ground: ALL components (ESP32, L298N, Sensors) MUST share the same GND.

BOT PLACEMENT: 
- Initially, place the bots within 1 meter of each other with overlapping fields 
  of view. This ensures the central server can successfully merge their maps 
  using the ICP algorithm.

4. SCOPE & NAVIGATION
---------------------
- Vision & Mapping: YES. Complete pipeline from LiDAR to global occupancy grid.
- Navigation: YES. The system supports remote movement commands.
- Motor Control: Integrated Differential Drive logic for L298N driver.

HOW TO MOVE THE BOTS:
1. Ensure the Micro-ROS agent is running.
2. Publish movement commands to the `/agent_1/cmd_vel` topic (Agent 2 uses `/agent_2/cmd_vel`).
3. Use the ROS 2 teleop tool to drive them manually:
   ```bash
   ros2 run teleop_twist_keyboard teleop_twist_keyboard --ros-args -r /cmd_vel:=/agent_1/cmd_vel
   ```
4. Safety Feature: The motors will automatically stop if no command is received 
   for more than 500ms (to prevent "runaway" robots).

5. HOW TO OPERATE
-----------------
1. Wiring: Connect components according to the table in Section 3.
2. Setup: Update `WIFI_SSID`, `WIFI_PASSWORD`, and `agent_ip` in `main.cpp`.
3. Build & Flash: Use PlatformIO to upload the firmware to all ESP32 agents.
4. Micro-ROS: Start the agent: `ros2 run micro_ros_agent micro_ros_agent udp4 --port 8888`.
5. Server: Run the map merger: `ros2 run <pkg_name> map_merger`.
6. Control: Use `teleop_twist_keyboard` as described above to drive and map.

================================================================================
END OF GUIDE
================================================================================
